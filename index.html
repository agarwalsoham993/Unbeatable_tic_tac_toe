<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>C++ Tic-Tac-Toe (Optimal Bot) - JS Port</title>
    <style>
        body { font-family: sans-serif; text-align: center; background-color: #1f1e1e; color: #eee; padding-bottom: 50px; }
        h1 { color: #00aaff; }
        #score { color: #9ec1d2; font-size: 1.2em; margin-bottom: 20px;}
        #status { font-size: 1.5em; margin: 20px; height: 30px; }
        #board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 5px;
            justify-content: center;
        }
        .cell {
            width: 100px;
            height: 100px;
            background-color: #444;
            border: 2px solid #555;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .cell:hover:not(.disabled) { background-color: #555; }
        .cell.X { color: #ff4757; }
        .cell.O { color: #5352ed; }
        .cell.win { background-color: #3d5e3d; }
        button {
            margin-top: 20px;
            margin-left: 10px;
            margin-right: 10px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #00aaff;
            color: white;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #0088cc; }
        /* Style for the Min-Max button to differentiate it */
        #minMaxButton {
            background-color: #e056fd;
        }
        #minMaxButton:hover {
            background-color: #be2edd;
        }
        .disabled { pointer-events: none; opacity: 0.7; }
        footer { margin-top: 40px; color: #888; }
        footer a { color: #00aaff; text-decoration: none; }
        footer a:hover { text-decoration: underline; }
        #modeDisplay { margin-top: 10px; color: #fab1a0; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Tic-Tac-Toe Optimal Bot</h1>
    <div id="score">Bot Wins: 0     Player Wins: 0     Draws: 0</div>
    <div id="status">Loading...</div>
    <div id="modeDisplay">Current Algorithm: Original Ported Logic</div>
    <div id="board"></div>
    
    <div>
        <button id="resetButton">New Game</button>
        <button id="minMaxButton">Compare with Min-Max</button>
    </div>

    <footer>
        <p>View the source code on <a id="repoLink" href="https://github.com/YOUR_USERNAME/YOUR_REPOSITORY" target="_blank">GitHub</a>.</p>
        <p>Original C++ logic ported to JavaScript. Min-Max added for comparison.</p>
    </footer>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const minMaxButton = document.getElementById('minMaxButton');
        const scoreElement = document.getElementById('score');
        const modeDisplay = document.getElementById('modeDisplay');

        // Game constants
        const EMPTY = 2;
        const PLAYER = 1; // X (Human)
        const BOT = 0;    // O (AI)

        // Game state
        let board = [EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY];
        let playerStartsNext = true;
        let score = { bot: 0, player: 0, draws: 0 };
        let useMinMax = false; // Toggle state for algorithm
        
        const WINNING_LINES = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
            [0, 4, 8], [2, 4, 6]             // diagonals
        ];
        
        // --- Shared Logic ---

        function checkGameStatus(currentBoard) {
            for (const line of WINNING_LINES) {
                const [a, b, c] = line;
                if (currentBoard[a] !== EMPTY && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
                    return { status: currentBoard[a], line: line }; // Returns winner (0 or 1)
                }
            }
            if (currentBoard.every(cell => cell !== EMPTY)) {
                return { status: 3, line: null }; // 3 for Draw
            }
            return { status: 2, line: null }; // 2 for Ongoing
        }

        // --- Original C++ Logic Ported ---
        
        function findWinningMove(currentBoard, player) {
            for (let i = 0; i < 9; i++) {
                if (currentBoard[i] === EMPTY) {
                    const boardCopy = [...currentBoard];
                    boardCopy[i] = player;
                    if (checkGameStatus(boardCopy).status === player) {
                        return i;
                    }
                }
            }
            return null;
        }
        
        function weighMoves(currentBoard, weights, player) {
            const otherPlayer = (player === BOT) ? PLAYER : BOT;
            for (const line of WINNING_LINES) {
                const values = line.map(i => currentBoard[i]);
                if (!values.includes(otherPlayer)) {
                    line.forEach(index => {
                        if (currentBoard[index] === EMPTY) {
                            weights[index]++;
                        }
                    });
                }
            }
        }
        
        function getHeuristicMove(currentBoard, player) {
            let move = findWinningMove(currentBoard, player);
            if (move !== null) return move;
            
            const opponent = (player === BOT) ? PLAYER : BOT;
            move = findWinningMove(currentBoard, opponent);
            if (move !== null) return move;

            const weights = Array(9).fill(0);
            weighMoves(currentBoard, weights, player);
            weighMoves(currentBoard, weights, opponent);

            let maxWeight = -1;
            for(let i = 0; i < 9; i++) {
                if(currentBoard[i] === EMPTY) {
                    maxWeight = Math.max(maxWeight, weights[i]);
                }
            }
            
            const bestMoves = [];
            for (let i = 0; i < 9; i++) {
                if (currentBoard[i] === EMPTY && weights[i] === maxWeight) {
                    bestMoves.push(i);
                }
            }
            
            if (bestMoves.length > 0) {
                return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }

            const available = [];
            for(let i=0; i<9; i++) if(currentBoard[i] === EMPTY) available.push(i);
            return available[Math.floor(Math.random() * available.length)];
        }

        function projectGameOutcome(currentBoard, currentPlayer) {
            const status = checkGameStatus(currentBoard).status;
            if (status !== 2) {
                return status;
            }
            const move = getHeuristicMove(currentBoard, currentPlayer);
            const boardCopy = [...currentBoard];
            boardCopy[move] = currentPlayer;

            const nextPlayer = (currentPlayer === BOT) ? PLAYER : BOT;
            return projectGameOutcome(boardCopy, nextPlayer);
        }

        function findBotMoveOriginal(currentBoard) {
            const opponent = PLAYER;

            let move = findWinningMove(currentBoard, BOT);
            if (move !== null) return move;
            
            move = findWinningMove(currentBoard, opponent);
            if (move !== null) return move;

            const weights = Array(9).fill(0);
            weighMoves(currentBoard, weights, BOT);
            weighMoves(currentBoard, weights, opponent);

            let maxWeight = -1;
            for (let i = 0; i < 9; i++) {
                if (currentBoard[i] === EMPTY) {
                    maxWeight = Math.max(maxWeight, weights[i]);
                }
            }

            const bestMoves = [];
            for (let i = 0; i < 9; i++) {
                if (currentBoard[i] === EMPTY && weights[i] === maxWeight) {
                    bestMoves.push(i);
                }
            }

            const safeMoves = [];
            for (const m of bestMoves) {
                const boardCopy = [...currentBoard];
                boardCopy[m] = BOT;
                if (projectGameOutcome(boardCopy, opponent) !== opponent) {
                    safeMoves.push(m);
                }
            }

            if (safeMoves.length > 0) {
                return safeMoves[Math.floor(Math.random() * safeMoves.length)];
            }
            if (bestMoves.length > 0) {
                 return bestMoves[Math.floor(Math.random() * bestMoves.length)];
            }
            const available = [];
            for(let i=0; i<9; i++) if(currentBoard[i] === EMPTY) available.push(i);
            return available[0];
        }

        // --- New Min-Max Algorithm ---

        function minimax(currentBoard, depth, isMaximizing) {
            const result = checkGameStatus(currentBoard).status;
            
            // Terminal states
            if (result === BOT) return 10 - depth; // Bot wins
            if (result === PLAYER) return depth - 10; // Player wins
            if (result === 3) return 0; // Draw

            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (currentBoard[i] === EMPTY) {
                        currentBoard[i] = BOT;
                        let score = minimax(currentBoard, depth + 1, false);
                        currentBoard[i] = EMPTY; // Undo move
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (currentBoard[i] === EMPTY) {
                        currentBoard[i] = PLAYER;
                        let score = minimax(currentBoard, depth + 1, true);
                        currentBoard[i] = EMPTY; // Undo move
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }

        function findBotMoveMinMax(currentBoard) {
            let bestScore = -Infinity;
            let move = -1;
            
            // If it's the very first move of the game, pick center or corner to save computation
            // (Minimax is fast enough for 3x3, but this is a common optimization)
            const emptyCount = currentBoard.filter(c => c === EMPTY).length;
            if (emptyCount === 9) return 4; // Center

            for (let i = 0; i < 9; i++) {
                if (currentBoard[i] === EMPTY) {
                    currentBoard[i] = BOT;
                    let score = minimax(currentBoard, 0, false);
                    currentBoard[i] = EMPTY;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        move = i;
                    }
                }
            }
            return move;
        }

        // --- UI and Game Flow ---

        function createBoard() {
            boardElement.innerHTML = ''; // Clear existing
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.addEventListener('click', () => onCellClick(i));
                boardElement.appendChild(cell);
            }
        }

        function onCellClick(index) {
            if (board[index] !== EMPTY || checkGameStatus(board).status !== 2) {
                return;
            }

            board[index] = PLAYER;
            updateUI();
            const gameStatus = checkGameStatus(board);
            if (gameStatus.status !== 2) {
                endGame(gameStatus);
                return;
            }

            statusElement.textContent = `Bot Thinking (${useMinMax ? 'Min-Max' : 'Original'})...`;
            boardElement.classList.add('disabled');

            setTimeout(() => {
                let botMove;
                if (useMinMax) {
                    botMove = findBotMoveMinMax(board);
                } else {
                    botMove = findBotMoveOriginal(board);
                }

                if (botMove !== null && botMove !== -1) {
                    board[botMove] = BOT;
                }
                updateUI();
                const botGameStatus = checkGameStatus(board);
                if (botGameStatus.status !== 2) {
                    endGame(botGameStatus);
                } else {
                    statusElement.textContent = "Your Turn (X)";
                    boardElement.classList.remove('disabled');
                }
            }, 300); // Slight delay for UX
        }

        function resetGame() {
            board.fill(EMPTY);
            
            playerStartsNext = !playerStartsNext;
            if (!playerStartsNext) { // Bot starts
                // Bot move based on selected algorithm
                let firstMove;
                if (useMinMax) {
                     firstMove = findBotMoveMinMax(board);
                } else {
                     firstMove = findBotMoveOriginal(board);
                }
                board[firstMove] = BOT;
                statusElement.textContent = "Your Turn (X)";
            } else { // Player starts
                 statusElement.textContent = "Your Turn (X)";
            }
            
            updateUI();
            boardElement.classList.remove('disabled');
        }

        function toggleAlgorithm() {
            useMinMax = !useMinMax;
            if (useMinMax) {
                modeDisplay.textContent = "Current Algorithm: Min-Max (Unbeatable)";
                minMaxButton.textContent = "Switch back to Original";
            } else {
                modeDisplay.textContent = "Current Algorithm: Original Ported Logic";
                minMaxButton.textContent = "Compare with Min-Max";
            }
            // Optional: Auto-reset game on switch to ensure fair start?
            // User can just press New Game manually.
        }

        function updateUI() {
            board.forEach((value, index) => {
                const cell = boardElement.children[index];
                cell.textContent = value === PLAYER ? 'X' : value === BOT ? 'O' : '';
                cell.classList.remove('X', 'O', 'win');
                if (value === PLAYER) cell.classList.add('X');
                if (value === BOT) cell.classList.add('O');
            });
        }

        function endGame(gameStatus) {
            let message = '';
            if (gameStatus.status === PLAYER) {
                message = 'You Win! (X)';
                score.player++;
            } else if (gameStatus.status === BOT) {
                message = 'Bot Wins! (O)';
                score.bot++;
            } else {
                message = "It's a Draw!";
                score.draws++;
            }
            statusElement.textContent = message;
            boardElement.classList.add('disabled');

            if (gameStatus.line) {
                gameStatus.line.forEach(index => {
                    boardElement.children[index].classList.add('win');
                });
            }
            
            updateScore();
            saveScore();
        }

        function updateScore() {
            scoreElement.innerHTML = `Bot Wins: ${score.bot}     Player Wins: ${score.player}     Draws: ${score.draws}`;
        }

        function saveScore() {
            localStorage.setItem('ticTacToeScore', JSON.stringify(score));
        }

        function loadScore() {
            const savedScore = localStorage.getItem('ticTacToeScore');
            if (savedScore) {
                score = JSON.parse(savedScore);
            }
            updateScore();
        }
        
        // --- Initialization ---
        resetButton.addEventListener('click', resetGame);
        minMaxButton.addEventListener('click', toggleAlgorithm);
        
        createBoard();
        loadScore();
        resetGame(); // Start the first game
    </script>
</body>
</html>
